{-# LANGUAGE AllowAmbiguousTypes #-}

daml 1.2
module OpenworkBoard.V4.Upgrade where

import DA.Action
import qualified DA.List as List
import qualified DA.Next.Map as Map
import DA.Tuple

import qualified Danban.V3 as DanbanV3
import qualified Danban.V3.Board as BoardV3
import qualified Danban.V3.Role as RoleV3
import qualified Danban.V3.Rules as RulesV3
import qualified Danban.V3.User as UserV3

import qualified OpenworkBoard.V4 as OWBV4
import qualified OpenworkBoard.V4.Board as BoardV4
import qualified OpenworkBoard.V4.Role as RoleV4
import qualified OpenworkBoard.V4.Rules as RulesV4
import qualified OpenworkBoard.V4.User as UserV4

import OpenworkBoard.V4.Util

forA_ xs f = void (forA xs f)

class Upgradable a b where
  upgrade : a -> b

-- Define the conversion rules

instance Upgradable UserV4.Directory UserV4.Directory where
  upgrade UserV3.Directory{..} = UserV4.Directory{..}

upgradeProfile : Party -> Party -> Update (ContractId UserV4.Profile)
upgradeProfile operator party = do
  (cid, UserV3.Profile{..}) <- fetchByKey @UserV3.Profile (operator, party)
  archive cid
  (_, ud) <- fetchByKey @UserV4.Directory operator
  create UserV4.Profile with
    obs = ud.users
    ..

instance Upgradable BoardV3.Directory BoardV3.Directory where
  upgrade BoardV3.Directory{..} = BoardV4.Directory{..}

instance Upgradable BoardV3.Data BoardV4.Data where
  upgrade BoardV3.Data{..} = BoardV4.Data{..}

instance Upgradable BoardV3.CardList BoardV4.CardList where
  upgrade BoardV3.CardList{..} = BoardV4.CardList{..}

instance Upgradable BoardV3.Card BoardV4.Card where
  upgrade BoardV3.Card{..} = BoardV4.Card{..}

instance Upgradable RulesV3.Board RulesV4.Board where
  upgrade RulesV3.Board{..} = RulesV4.Board{..}

deriving instance Enum RulesV3.AccessLevel
deriving instance Enum RulesV4.AccessLevel
instance Upgradable RulesV3.AccessLevel RulesV4.AccessLevel where
  upgrade = toEnum . fromEnum

upgradeByKey : forall a b k . (Template b, TemplateKey a k, Upgradable a b) => k -> Update (ContractId b, b)
upgradeByKey k = do
  (cid, args) <- fetchByKey @a k
  archive cid
  let b = upgrade args
  bcid <- create @b b
  return (bcid, b)

upgradeIfKey : forall a b k . (Template b, TemplateKey a k, Upgradable a b) => k -> Update (Optional (ContractId b, b))
upgradeIfKey k = do
  oCid <- lookupByKey @a k
  case oCid of
    Some cid -> Some <$> upgradeByKey @a k
    None -> return None

updateMap : (Map.MapKey k) => k -> (v -> v) -> Map.Map k v -> Map.Map k v
updateMap k fn m = case Map.lookup k m of
  None -> m
  Some v -> Map.insert k (fn v) m

template UpgradeInitiator
  with
    operator: Party
  where
    signatory operator

    controller operator can
      InitiateUpgrade
        : ()
        do
          -- Convert admin contracts
          exerciseIfKey @DanbanV3.Admin operator Archive
          newAdminCid <- create OWBV4.Admin with operator
          (_, UserV4.Directory{users}) <- upgradeByKey @UserV3.Directory @UserV4.Directory operator

          -- Create Upgrade invitations for users and create board upgraders
          forA_ users (\party -> do
            exerciseByKey @RoleV3.User (operator, party) Archive
            create UpgradeInvite with ..
            )

          exercise newAdminCid DanbanV3.UnpauseApp
          return ()

template BoardUpgrader
  with
    operator : Party
    boardId : Text
    requiredSigs : [Party]
    sigs : [Party]
  where
    signatory operator :: sigs
    observer requiredSigs

    key (operator, boardId) : (Party, Text)
    maintainer key._1

    choice Sign
      : ()
      with
        party : Party
      controller party
      do
        assertMsg (show party <> " is not a required signatory") (party `elem` requiredSigs)
        let newSigs = List.dedupSort (party :: sigs)
        newSelf <- create this with sigs = newSigs
        when (newSigs == requiredSigs) (exercise newSelf UpgradeBoard)
    
    controller operator can
      UpgradeBoard
        : ()
        do
          upgradeByKey @RulesV3.Board @RulesV4.Board (operator, boardId)
          (_, newBoard) <- upgradeByKey @BoardV3.Data @BoardV4.Data (operator, boardId)
          forA_ newBoard.lists (\listId -> do
            (_, newList) <- upgradeByKey @BoardV3.CardList @BoardV4.CardList (operator, listId)
            forA_ newList.cards (\cardId -> upgradeByKey @BoardV3.Card @BoardV4.Card (operator, cardId))
            )

template UpgradeInvite
  with
    operator : Party
    party : Party
  where
    signatory operator

    key (operator, party) : (Party, Party)
    maintainer key._1

    controller party can
      Accept_Upgrade
        : ()
        do
          upgradeProfile operator party
          create RoleV4.User with ..
          o <- upgradeIfKey @BoardV3.Directory @BoardV4.Directory (operator, party)
          case o of
            Some (_, bd) ->  forA_ bd.boards (\boardId -> do
              oCid <- lookupByKey @BoardUpgrader (operator, boardId)
              cid <- case oCid of
                Some cid -> return cid
                None -> do
                  (_, board) <- fetchByKey @RulesV3.Board (operator, boardId)
                  create BoardUpgrader with
                    requiredSigs = List.dedupSort $ signatory board
                    sigs = [operator]
                    ..
              void $ exercise cid Sign with ..
              )
            None -> return ()
