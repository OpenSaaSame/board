daml 1.2
module Danban where

import DA.Action
import DA.List
import DA.Optional

move : Int -> Int -> [a] -> [a]
move oldIdx newIdx xs =
  let lowIdx = min oldIdx newIdx
      highIdx = max oldIdx newIdx
      (s1, r) = splitAt lowIdx xs
      (s2, s3) = splitAt (highIdx - lowIdx) r
      (s2', s3') = if oldIdx < newIdx
        then (tail s2, head s3 :: head s2 :: tail s3)
        else (head s3 :: s2, tail s3)
  in s1 ++ s2' ++ s3'

takeAt : Int -> [a] -> (a, [a])
takeAt idx xs
  | idx < 0 = error "Only positive indices allowed"
  | idx == 0 = (head xs, tail xs)
  | otherwise =
    let (x, xs') = takeAt (idx - 1) (tail xs)
    in (x, head xs :: xs')

insertAt : Int -> a -> [a] -> [a]
insertAt idx x xs
  | idx < 0 = error "Only positive indices allowed"
  | idx == 0 = x :: xs
  | otherwise = head xs :: insertAt (idx - 1) x (tail xs)

template DanbanApp
  with
    operator: Party
  where
    signatory operator

    key operator : Party
    maintainer key

    controller operator can
      nonconsuming StartApp
        : ()
        do
          create UserDirectory with operator; users = []
          create BoardDirectory with operator; users = []; boards = []
          create AppSemaphore with operator; users = []
          return ()

      nonconsuming PauseApp
        : ()
        do exerciseByKey @AppSemaphore operator Archive

      nonconsuming UnpauseApp
        : ContractId AppSemaphore
        do
          (_, ud) <- fetchByKey @UserDirectory operator
          create AppSemaphore with operator; users = ud.users

      nonconsuming AddUser
        : ContractId UserRole
        with
          party : Party
        do
          exerciseByKey @UserDirectory operator UserDirectory_AddObs with party
          exerciseByKey @BoardDirectory operator BoardDirectory_UpdateObs
          create UserRole with ..

template UserDirectory
  with
    operator : Party
    users : [Party]
  where
    signatory operator
    observer users

    key operator : Party
    maintainer key

    controller operator can
     UserDirectory_AddObs
        : ContractId UserDirectory
        with
          party : Party
        do
          ret <- create this with users = dedupSort (party :: users)
          forA users (\user -> exerciseByKey @UserProfile (operator, user) Profile_UpdateObs)
          return ret

template BoardDirectory
  with
    operator : Party
    users : [Party]
    boards : [Text]
  where
    signatory operator
    observer users

    key operator : Party
    maintainer key

    controller operator can
      BoardDirectory_UpdateObs
        : ContractId BoardDirectory
        do
          (_, userDirectory) <- fetchByKey @UserDirectory operator
          forA boards (\board -> exerciseByKey @Board (operator, board) Board_UpdateObs)
          create this with users = userDirectory.users

      BoardDirectory_AddBoard
        : ContractId BoardDirectory
        with
          board : Text
        do
          create this with boards = dedupSort (board :: boards)

      BoardDirectory_RemoveBoard
        : ContractId BoardDirectory
        with
          board : Text
        do
          create this with boards = delete board boards

-- AppSemaphore allows the op to stop all operattion, e.g. to do bulk updates
template AppSemaphore
  with
    operator : Party
    users : [Party]
  where
    signatory operator
    observer users

    key operator : Party
    maintainer key

-- UserRole gives a user the choices to operate on the app
template UserRole
  with
    party : Party
    operator : Party
  where
    signatory operator

    key (operator, party) : (Party, Party)
    maintainer key._1

    controller party can
      nonconsuming PutProfile
        : ContractId UserProfile
        with
          displayName : Text
          imageUrl : Text
        do
          fetchByKey @AppSemaphore operator
          (_, userDirectory) <- fetchByKey @UserDirectory operator
          oProfile <- lookupByKey @UserProfile (operator, party)
          when (isSome oProfile) (archive (fromSome oProfile))
          create UserProfile with obs = userDirectory.users, ..

      nonconsuming ADD_BOARD
        : ContractId Board
        with
          boardId : Text
          title : Text
        do
          fetchByKey @AppSemaphore operator
          exerciseByKey @BoardDirectory operator BoardDirectory_AddBoard with 
            board = boardId
          create Board with
            _id = boardId
            operator
            admins = [party]
            obs = []
            title
            color = "blue"
            users = []
            lists = []

      nonconsuming DELETE_BOARD
        : ()
        with
          boardId : Text
        do
          fetchByKey @AppSemaphore operator

          oOldCid <- lookupByKey @Board (operator, boardId)
          case oOldCid of
            Some oldCid -> do
              exerciseByKey @BoardDirectory operator BoardDirectory_RemoveBoard with
                board = boardId
              exercise oldCid Board_Delete
            _ -> return ()

      nonconsuming CHANGE_BOARD_TITLE
        : ContractId Board
        with
          boardId : Text
          newTitle : Text
        do
          fetchByKey @AppSemaphore operator
          (oldCid, oldBoard) <- fetchByKey @Board (operator, boardId)
          archive oldCid
          create oldBoard with title = newTitle

      nonconsuming CHANGE_BOARD_COLOR
        : ContractId Board
        with
          boardId : Text
          newColor : Text
        do
          fetchByKey @AppSemaphore operator
          (oldCid, oldBoard) <- fetchByKey @Board (operator, boardId)
          archive oldCid
          create oldBoard with color = newColor

      nonconsuming ADD_LIST
        : ContractId CardList
        with
          boardId : Text
          listId : Text
          title : Text
        do
          fetchByKey @AppSemaphore operator
          (oldCid, board) <- fetchByKey @Board (operator, boardId)
          archive oldCid
          create board with lists = board.lists ++ [listId]
          create CardList with
            _id = listId
            admins = board.admins
            obs = board.obs
            operator = board.operator
            boardId
            title
            cards = []

      nonconsuming DELETE_LIST
        : ()
        with
          boardId : Text
          listId : Text
        do
          fetchByKey @AppSemaphore operator
          (oldCid, board) <- fetchByKey @Board (operator, boardId)
          archive oldCid
          create board with lists = delete listId board.lists
          exerciseByKey @CardList (operator, listId) List_Delete
      
      nonconsuming MOVE_LIST
        : ContractId Board
        with
          boardId : Text
          oldIdx : Int
          newIdx : Int
        do
          fetchByKey @AppSemaphore operator
          (oldCid, board) <- fetchByKey @Board (operator, boardId)
          archive oldCid
          create board with lists = move oldIdx newIdx board.lists
      
      nonconsuming CHANGE_LIST_TITLE
        : ContractId CardList
        with
          listId : Text
          newTitle : Text
        do
          fetchByKey @AppSemaphore operator
          (oldCid, list) <- fetchByKey @CardList (operator, listId)
          archive oldCid
          create list with title = newTitle

      nonconsuming ADD_CARD
        : ContractId Card
        with
          listId : Text
          cardId : Text
          text : Text
        do
          fetchByKey @AppSemaphore operator
          (oldCid, list) <- fetchByKey @CardList (operator, listId)
          archive oldCid
          create list with cards = list.cards ++ [cardId]
          create Card with
            _id = cardId
            admins = list.admins
            obs = list.obs
            operator = list.operator
            boardId = list.boardId
            listId
            text
            color = None
            date = None

      nonconsuming MOVE_CARD
        : ()
        with
          sourceListId : Text
          destListId : Text
          oldIdx : Int
          newIdx : Int
        do
          fetchByKey @AppSemaphore operator
          if(sourceListId == destListId)
            then do
              (oldCid, list) <- fetchByKey @CardList (operator, sourceListId)
              archive oldCid
              create list with cards = move oldIdx newIdx list.cards
              return ()
            else do
              (oldSourceCid, source) <- fetchByKey @CardList (operator, sourceListId)
              (oldDestCid, dest) <- fetchByKey @CardList (operator, destListId)
              archive oldSourceCid
              archive oldDestCid
              let (x, newSourceCards) = takeAt oldIdx source.cards
              create source with cards = newSourceCards
              create dest with cards = insertAt newIdx x dest.cards
              return ()

      nonconsuming DELETE_CARD
        : ContractId CardList
        with
          listId : Text
          cardId : Text
        do
          (oldCid, list) <- fetchByKey @CardList (operator, listId)
          archive oldCid
          exerciseByKey @Card (operator, cardId) Card_Delete
          create list with cards = delete cardId list.cards

      nonconsuming CHANGE_CARD_TEXT
        : ContractId Card
        with
          cardId : Text
          newText : Text
        do
          (oldCid, card) <- fetchByKey @Card (operator, cardId)
          archive oldCid
          create card with text = newText

      nonconsuming CHANGE_CARD_DATE
        : ContractId Card
        with
          cardId : Text
          newDate : Optional Time
        do
          (oldCid, card) <- fetchByKey @Card (operator, cardId)
          archive oldCid
          create card with date = newDate

      nonconsuming CHANGE_CARD_COLOR
        : ContractId Card
        with
          cardId : Text
          newColor : Optional Text
        do
          (oldCid, card) <- fetchByKey @Card (operator, cardId)
          archive oldCid
          create card with color = newColor

template UserProfile
  with
    party : Party
    operator : Party
    obs : [Party]
    displayName : Text
    imageUrl : Text
  where
    signatory party, operator
    observer obs

    key (operator, party) : (Party, Party)
    maintainer key._1, key._2

    controller operator can
      Profile_UpdateObs
        : ContractId UserProfile
        do
          (_, userDirectory) <- fetchByKey @UserDirectory operator
          create this with obs = userDirectory.users

type BoardKey = (Party, Text)


template Board
  with
    _id : Text
    operator : Party
    admins : [Party]
    obs : [Party]

    title : Text
    color : Text
    users : [Party]
    lists : [Text]
  where
    signatory operator, admins
    observer users, obs

    key (operator, _id) : (Party, Text)
    maintainer key._1

    controller operator can
      Board_UpdateObs
        : ContractId Board
        do
          (_, userDirectory) <- fetchByKey @UserDirectory operator
          forA lists (\list -> exerciseByKey @CardList (operator, list) List_UpdateObs)
          create this with obs = userDirectory.users

    controller admins can
      Board_Delete
        : ()
        do
          forA lists (\list -> exerciseByKey @CardList (operator, list) List_Delete)
          return ()

          

template CardList 
  with
    _id : Text
    operator : Party
    admins : [Party]
    obs : [Party]

    boardId : Text
    title : Text
    cards : [Text]
  where
    signatory operator, admins
    observer obs

    key (operator, _id) : (Party, Text)
    maintainer key._1

    controller operator can
      List_UpdateObs
        : ContractId CardList
        do
          (_, userDirectory) <- fetchByKey @UserDirectory operator
          forA cards (\card -> exerciseByKey @Card (operator, card) Card_UpdateObs)
          create this with obs = userDirectory.users

    controller admins can
      List_Delete
        : ()
        do
          forA cards (\card -> exerciseByKey @Card (operator, card) Card_Delete)
          return ()

type CardKey = (Party, Text, Text, Text)

template Card
  with
    _id : Text
    operator : Party
    admins : [Party]
    obs : [Party]

    boardId : Text
    listId : Text
    color : Optional Text
    text : Text
    date : Optional Time
  where
    signatory operator, admins
    observer obs

    key (operator, _id) : (Party, Text)
    maintainer key._1

    controller operator can
      Card_UpdateObs
        : ContractId Card
        do
          (_, userDirectory) <- fetchByKey @UserDirectory operator
          create this with obs = userDirectory.users

    controller admins can
      Card_Delete
        : ()
        do
          return ()

startApp = scenario do
  admin <- getParty "Admin"
  app <- submit admin do
    create DanbanApp with operator = admin
  submit admin do
    exercise app StartApp